<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Wer bin ich?</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 1100px;
      margin: auto;
      padding: 20px;
      min-height: 100vh;
      background: linear-gradient(140deg, #e7edf8 0%, #f5f1ff 100%);
    }

    .app {
      background: rgba(255, 255, 255, 0.85);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 18px rgba(0, 0, 0, 0.2);
    }

    input, button, select { margin: 5px 0; padding: 5px; width: 100%; }
    .hidden { display: none; }

    #playerList {
      list-style: none;
      padding: 0;
      margin: 10px 0;
    }

    #playerList li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 6px;
    }

    #playerList button {
      width: auto;
      padding: 4px 8px;
      margin: 0;
    }

    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 14px;
      margin-top: 14px;
    }

    .player-card {
      border-radius: 14px;
      overflow: hidden;
      min-height: 300px;
      position: relative;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 8px 20px rgba(16, 24, 40, 0.3);
      background: #29324f;
      background-size: cover;
      background-position: center;
      display: flex;
      align-items: flex-end;
    }

    .player-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(10, 12, 25, 0.86) 15%, rgba(10, 12, 25, 0.35) 55%, rgba(10, 12, 25, 0.1) 100%);
    }

    .card-content {
      position: relative;
      z-index: 1;
      width: 100%;
      padding: 12px;
      backdrop-filter: blur(1.5px);
    }

    .card-status {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.72rem;
      margin-bottom: 6px;
      opacity: 0.85;
    }

    .card-name {
      margin: 0;
      font-size: 1.2rem;
      line-height: 1.2;
    }

    .card-character {
      margin: 6px 0 0;
      font-size: 0.95rem;
      opacity: 0.95;
    }
  </style>
</head>
<body>

<div class="app">
<h1>Wer bin ich?</h1>
<button id="abortRoundBtn" class="hidden" onclick="abortRound()">Spiel abbrechen</button>

<!-- Spieler anmelden -->
<div id="registerDiv" class="hidden">
  <h2>Spieler anmelden</h2>
  <input type="text" id="playerName" placeholder="Dein Name">
  <button onclick="registerPlayer()">Anmelden</button>
  <p id="registerMsg"></p>

  <h3>Aktuell angemeldet</h3>
  <ul id="playerList"></ul>
  <button id="beginAssignBtn" class="hidden" onclick="beginAssignment()">Runde starten</button>
</div>

<!-- Runde starten -->
<div id="startDiv">
  <h2>Spiel starten</h2>
  <button onclick="startRound()">Spiel starten</button>
</div>

<!-- Figur zuweisen -->
<div id="assignDiv" class="hidden">
  <h2>Figur zuweisen</h2>
  <p id="assignedText"></p>
  <input type="text" id="characterInput" placeholder="Figur eingeben">
  <button onclick="submitCharacter()">Absenden</button>
</div>

<!-- Ergebnisse -->
<div id="resultDiv" class="hidden">
  <h2>Ergebnisse</h2>
  <button id="guessBtn" onclick="guessCharacter()">Erraten</button>
  <p id="guessMsg"></p>
  <div id="results"></div>
</div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
import { getFirestore, collection, getDocs, setDoc, doc, updateDoc, deleteDoc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: typeof api_key !== "undefined" ? api_key : "",
  authDomain: "wer-bin-ich-a160b.firebaseapp.com",
  projectId: "wer-bin-ich-a160b",
  storageBucket: "wer-bin-ich-a160b.firebasestorage.app",
  messagingSenderId: "40347667202",
  appId: "1:40347667202:web:69d18b15506b7f2510501b"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

let currentPlayer = localStorage.getItem("werBinIchName") || "";
let assignedPlayer = "";

const clientId = localStorage.getItem("werBinIchClientId") || crypto.randomUUID();
localStorage.setItem("werBinIchClientId", clientId);
const roundRef = doc(db, "meta", "round");
let roundStateCache = null;
const imageCache = {};

async function getRoundDataSafe() {
  try {
    const roundSnap = await getDoc(roundRef);
    roundStateCache = roundSnap.exists() ? roundSnap.data() : null;
    return roundStateCache;
  } catch (error) {
    console.error("Round-Status konnte nicht geladen werden:", error);
    return roundStateCache;
  }
}

function showScreen(screen) {
  document.getElementById("registerDiv").classList.toggle("hidden", screen !== "register");
  document.getElementById("startDiv").classList.toggle("hidden", screen !== "start");
  document.getElementById("assignDiv").classList.toggle("hidden", screen !== "assign");
  document.getElementById("resultDiv").classList.toggle("hidden", screen !== "result");
  if (screen !== "result") document.getElementById("guessMsg").innerText = "";
}

function isHost(roundData) {
  return roundData && roundData.hostId === clientId;
}

function updateHostControls(roundData) {
  document.getElementById("abortRoundBtn").classList.toggle("hidden", !isHost(roundData));
}

async function ensureHost(actionText) {
  const roundData = await getRoundDataSafe();
  if (!isHost(roundData)) {
    alert(`Nur der Starter kann ${actionText}.`);
    return null;
  }
  return roundData;
}

async function getCurrentPlayerDoc() {
  if (!currentPlayer) return null;
  const meSnap = await getDoc(doc(db, "players", currentPlayer));
  if (!meSnap.exists()) return null;
  return meSnap.data();
}

async function registerPlayer() {
  const name = document.getElementById("playerName").value.trim();
  if (!name) return alert("Bitte Name eingeben!");

  currentPlayer = name;
  localStorage.setItem("werBinIchName", name);

  await setDoc(doc(db, "players", name), { name, assignedTo: "", character: "", ownerId: clientId, guessed: false });
  document.getElementById("registerMsg").innerText = `Du bist angemeldet als ${name}`;
  document.getElementById("playerName").value = "";
  await renderPlayers();
}

async function startRound() {
  // Sofort lokale Ansicht umschalten, auch falls die Remote-Aktualisierung fehlschlägt
  roundStateCache = { phase: "register", hostId: clientId, startedAt: Date.now() };
  showScreen("register");

  try {
    await setDoc(roundRef, roundStateCache);
  } catch (error) {
    console.error("Spielstart konnte nicht in Firestore gespeichert werden:", error);
    alert("Spielstart lokal aktiviert. Falls andere Geräte nichts sehen, bitte Firestore-Regeln prüfen.");
  }

  await renderPlayers();
  alert("Anmelden ist jetzt sichtbar. Als Starter kannst du Namen entfernen und dann auf 'Runde starten' klicken.");
}

function assignDerangement(players) {
  let shuffled = [...players];
  let valid = false;

  while (!valid) {
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }

    valid = true;
    for (let i = 0; i < players.length; i++) {
      if (players[i] === shuffled[i]) {
        valid = false;
        break;
      }
    }
  }

  const assignments = {};
  for (let i = 0; i < players.length; i++) {
    assignments[players[i]] = shuffled[i];
  }
  return assignments;
}

async function assignPlayers() {
  const snapshot = await getDocs(collection(db, "players"));
  const players = snapshot.docs.map(d => d.data().name).filter(Boolean);

  if (players.length < 2) {
    alert("Mindestens 2 Spieler benötigt.");
    return false;
  }

  const assignments = assignDerangement(players);
  for (const giver of players) {
    await updateDoc(doc(db, "players", giver), { assignedTo: assignments[giver] });
  }

  await loadAssignedPlayer();
  return true;
}

async function beginAssignment() {
  const roundData = await ensureHost("die Runde starten");
  if (!roundData) return;

  const ok = await assignPlayers();
  if (!ok) return;

  roundStateCache = { ...(roundStateCache || {}), phase: "assign", hostId: clientId };
  try {
    await updateDoc(roundRef, { phase: "assign" });
  } catch (error) {
    console.error("Rundenphase konnte nicht gespeichert werden:", error);
    showScreen("assign");
    await loadAssignedPlayer();
  }
}

async function loadAssignedPlayer() {
  const me = await getCurrentPlayerDoc();
  if (!me) return;

  assignedPlayer = me.assignedTo;
  if (!assignedPlayer) return;

  document.getElementById("assignedText").innerText = `Du weist ${assignedPlayer} eine Figur zu`;
}

async function submitCharacter() {
  const character = document.getElementById("characterInput").value.trim();
  if (!character) return alert("Bitte Figur eingeben!");

  await updateDoc(doc(db, "players", assignedPlayer), { character });
  alert(`Figur für ${assignedPlayer} gespeichert!`);
  document.getElementById("characterInput").value = "";

  showScreen("result");
  await showResult();
}

async function renderPlayers() {
  const roundData = await getRoundDataSafe();

  const snapshot = await getDocs(collection(db, "players"));
  const list = document.getElementById("playerList");
  list.innerHTML = "";

  snapshot.docs.forEach(d => {
    const data = d.data();
    if (!data.name) return;

    const li = document.createElement("li");
    const text = document.createElement("span");
    text.textContent = data.name;
    li.appendChild(text);

    if (isHost(roundData)) {
      const removeBtn = document.createElement("button");
      removeBtn.textContent = "Entfernen";
      removeBtn.onclick = () => removePlayer(data.name);
      li.appendChild(removeBtn);
    }

    list.appendChild(li);
  });

  document.getElementById("beginAssignBtn").classList.toggle("hidden", !isHost(roundData));
  updateHostControls(roundData);
}

async function removePlayer(name) {
  const roundData = await ensureHost("Spieler entfernen");
  if (!roundData) return;

  await deleteDoc(doc(db, "players", name));
  await renderPlayers();
}

async function showResult() {
  const resultsEl = document.getElementById("results");

  if (!currentPlayer) {
    resultsEl.innerHTML = "<p>Bitte zuerst anmelden.</p>";
    return;
  }

  const snapshot = await getDocs(collection(db, "players"));
  const players = snapshot.docs
    .map(d => d.data())
    .filter(data => data?.name);

  const cardsWithImage = await Promise.all(players.map(async (data) => {
    const visibleCharacter = data.name === currentPlayer ? "???" : (data.character || "—");
    const backgroundImage = data.name === currentPlayer
      ? fallbackImage("hidden-player")
      : await getImageFromWebSearch(data.character || data.name);
    return { data, visibleCharacter, backgroundImage };
  }));

  const grid = document.createElement("div");
  grid.className = "card-grid";

  cardsWithImage.forEach(({ data, visibleCharacter, backgroundImage }) => {
    const guessedBadge = data.guessed ? " · ✅ erraten" : "";

    const card = document.createElement("article");
    card.className = "player-card";
    card.style.backgroundImage = `url("${normalizeImageUrl(backgroundImage)}")`;

    const content = document.createElement("div");
    content.className = "card-content";

    const status = document.createElement("div");
    status.className = "card-status";
    status.textContent = `Spieler${guessedBadge}`;

    const name = document.createElement("h3");
    name.className = "card-name";
    name.textContent = data.name;

    const character = document.createElement("p");
    character.className = "card-character";
    character.textContent = visibleCharacter;

    content.appendChild(status);
    content.appendChild(name);
    content.appendChild(character);
    card.appendChild(content);
    grid.appendChild(card);
  });

  resultsEl.innerHTML = "";
  resultsEl.appendChild(grid);
}

function normalizeImageUrl(url) {
  if (!url) return "";
  return String(url).replace(/"/g, "%22");
}

function fallbackImage(query) {
  const seed = encodeURIComponent((query || "person").toLowerCase());
  return `https://picsum.photos/seed/${seed}/900/1200`;
}

async function getImageFromWebSearch(query) {
  const safeQuery = (query || "Person").trim();
  if (imageCache[safeQuery]) return imageCache[safeQuery];

  const wikidataImage = await getImageFromWikidata(safeQuery);
  if (wikidataImage) {
    imageCache[safeQuery] = wikidataImage;
    return wikidataImage;
  }

  try {
    const searchUrl = `https://de.wikipedia.org/w/api.php?action=query&list=search&format=json&origin=*&srsearch=${encodeURIComponent(safeQuery)}&srlimit=5`;
    const searchResponse = await fetch(searchUrl);
    const searchData = await searchResponse.json();
    const bestResult = chooseBestWikipediaResult(searchData?.query?.search || [], safeQuery);
    const firstResult = bestResult?.title;
    if (!firstResult) {
      imageCache[safeQuery] = fallbackImage(safeQuery);
      return imageCache[safeQuery];
    }

    const imageUrl = `https://de.wikipedia.org/w/api.php?action=query&prop=pageimages&piprop=original&titles=${encodeURIComponent(firstResult)}&format=json&origin=*`;
    const imageResponse = await fetch(imageUrl);
    const imageData = await imageResponse.json();
    const pages = imageData?.query?.pages || {};
    const page = Object.values(pages)[0];
    const webImage = page?.original?.source;

    imageCache[safeQuery] = webImage || fallbackImage(safeQuery);
    return imageCache[safeQuery];
  } catch (error) {
    console.error("Websuche für Kartenhintergrund fehlgeschlagen:", error);
    imageCache[safeQuery] = fallbackImage(safeQuery);
    return imageCache[safeQuery];
  }
}

function normalizeForSearch(text) {
  return String(text || "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function chooseBestWikipediaResult(results, query) {
  if (!Array.isArray(results) || results.length === 0) return null;

  const normalizedQuery = normalizeForSearch(query);
  const queryTokens = normalizedQuery.split(" ").filter(Boolean);

  const scored = results.map((item) => {
    const title = normalizeForSearch(item?.title);
    const snippet = normalizeForSearch(item?.snippet || "");

    let score = 0;
    if (title === normalizedQuery) score += 100;
    if (title.includes(normalizedQuery)) score += 30;
    if (snippet.includes(normalizedQuery)) score += 10;

    for (const token of queryTokens) {
      if (title.includes(token)) score += 6;
      if (snippet.includes(token)) score += 2;
    }

    return { item, score };
  });

  scored.sort((a, b) => b.score - a.score);
  return scored[0]?.item || null;
}

function buildCommonsFilePath(fileName) {
  if (!fileName) return "";
  return `https://commons.wikimedia.org/wiki/Special:FilePath/${encodeURIComponent(fileName.replace(/ /g, "_"))}`;
}

async function getImageFromWikidata(query) {
  try {
    const searchUrl = `https://www.wikidata.org/w/api.php?action=wbsearchentities&search=${encodeURIComponent(query)}&language=de&uselang=de&type=item&format=json&origin=*&limit=8`;
    const searchResponse = await fetch(searchUrl);
    const searchData = await searchResponse.json();
    const candidates = searchData?.search || [];
    if (!candidates.length) return "";

    const normalizedQuery = normalizeForSearch(query);
    const rankedCandidates = candidates
      .map((candidate) => {
        const label = normalizeForSearch(candidate?.label);
        const description = normalizeForSearch(candidate?.description);

        let score = 0;
        if (label === normalizedQuery) score += 100;
        if (label.includes(normalizedQuery)) score += 35;
        if (description.includes(normalizedQuery)) score += 8;

        return { candidate, score };
      })
      .sort((a, b) => b.score - a.score)
      .map((entry) => entry.candidate);

    for (const candidate of rankedCandidates) {
      const entityUrl = `https://www.wikidata.org/wiki/Special:EntityData/${candidate.id}.json`;
      const entityResponse = await fetch(entityUrl);
      const entityData = await entityResponse.json();
      const claims = entityData?.entities?.[candidate.id]?.claims;
      const imageFile = claims?.P18?.[0]?.mainsnak?.datavalue?.value;
      if (imageFile) return buildCommonsFilePath(imageFile);
    }

    return "";
  } catch (error) {
    console.warn("Wikidata-Bildsuche fehlgeschlagen:", error);
    return "";
  }
}

async function guessCharacter() {
  if (!currentPlayer) {
    alert("Bitte zuerst anmelden.");
    return;
  }

  const me = await getCurrentPlayerDoc();
  if (!me) {
    alert("Du bist aktuell nicht angemeldet.");
    return;
  }

  await updateDoc(doc(db, "players", currentPlayer), { guessed: true });
  document.getElementById("guessMsg").innerText = "Du hast auf 'Erraten' gedrückt.";
  await showResult();
}

async function abortRound() {
  const roundData = await ensureHost("das Spiel abbrechen");
  if (!roundData) return;

  const playersSnap = await getDocs(collection(db, "players"));
  for (const playerDoc of playersSnap.docs) {
    await deleteDoc(doc(db, "players", playerDoc.id));
  }

  await deleteDoc(roundRef);
  roundStateCache = null;
  showScreen("start");
  updateHostControls(null);
  alert("Spiel wurde abgebrochen.");
}

function subscribeRound() {
  onSnapshot(roundRef, async (snap) => {
    if (!snap.exists()) {
      roundStateCache = null;
      showScreen("start");
      updateHostControls(null);
      return;
    }

    const roundData = snap.data();
    roundStateCache = roundData;
    updateHostControls(roundData);

    if (roundData.phase === "register") {
      showScreen("register");
      await renderPlayers();
      return;
    }

    if (roundData.phase === "assign") {
      if (!currentPlayer) {
        showScreen("register");
        await renderPlayers();
        return;
      }

      const me = await getCurrentPlayerDoc();
      if (!me) {
        showScreen("register");
        await renderPlayers();
        return;
      }
      if (me.character) {
        showScreen("result");
        await showResult();
      } else {
        showScreen("assign");
        await loadAssignedPlayer();
      }
    }
  }, (error) => {
    console.error("Live-Synchronisierung fehlgeschlagen:", error);
    if (roundStateCache?.phase === "register") {
      showScreen("register");
    }
  });
}

window.registerPlayer = registerPlayer;
window.startRound = startRound;
window.beginAssignment = beginAssignment;
window.submitCharacter = submitCharacter;
window.removePlayer = removePlayer;
window.guessCharacter = guessCharacter;
window.abortRound = abortRound;

if (currentPlayer) {
  document.getElementById("registerMsg").innerText = `Du bist angemeldet als ${currentPlayer}`;
}

subscribeRound();
</script>

</body>
</html>
